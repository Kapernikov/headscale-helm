{{- if .Values.client.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "headscale.fullname" . }}-client-job-script
  labels:
    {{- include "headscale.labels" . | nindent 4 }}
data:
  ensure-client-key.sh: |
    #!/bin/sh
    # Idempotent preauth key management for the in-cluster tailscale client.
    # Safe to run repeatedly (helm hook or CronJob). Only creates a new key
    # when no valid one exists.
    set -eu
    apk add --no-cache jq >/dev/null 2>&1 || { echo "[ERROR] Failed to install jq via apk" >&2; exit 1; }

    NAMESPACE="{{ .Release.Namespace }}"
    APP_NAME="{{ include "headscale.name" . }}"
    FULLNAME="{{ include "headscale.fullname" . }}"
    RELEASE_NAME="{{ .Release.Name }}"
    LABEL_SELECTOR="app.kubernetes.io/component=server,app.kubernetes.io/instance=$RELEASE_NAME"

    CLIENT_USER=${CLIENT_USER:-headscale-system}
    SECRET_NAME=${SECRET_NAME:-"$FULLNAME-client-authkey"}

    # --- Step 1: Find ready headscale pod ---
    echo "[INFO] Locating a ready headscale pod (timeout ~5m)..."
    HEADSCALE_POD=""
    for i in $(seq 1 60); do
      CANDIDATE=$(kubectl get pods -n "$NAMESPACE" -l "$LABEL_SELECTOR" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' | head -n 1)
      if [ -n "$CANDIDATE" ]; then
        if kubectl wait --for=condition=ready "pod/$CANDIDATE" -n "$NAMESPACE" --timeout=5s >/dev/null 2>&1; then
          HEADSCALE_POD="$CANDIDATE"
          break
        fi
      fi
      echo "[INFO] Waiting for a ready pod... ($i/60)"
      sleep 5
    done
    if [ -z "${HEADSCALE_POD:-}" ]; then
      echo "[ERROR] No ready headscale pod found within timeout."
      kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name="$APP_NAME" -o wide || true
      exit 1
    fi
    echo "[INFO] Using pod: $HEADSCALE_POD"

    # --- Step 2: Ensure user exists ---
    echo "[INFO] Ensuring user '$CLIENT_USER' exists and obtaining ID..."
    USERS_JSON=$(kubectl exec -n "$NAMESPACE" "$HEADSCALE_POD" -c {{ .Chart.Name }} -- headscale users list --output json 2>/dev/null || printf 'null')
    USER_ID=$(printf "%s" "$USERS_JSON" | jq -r '(. // []) | .[] | select(.name=="'"$CLIENT_USER"'") | .id' | head -n1)
    if [ -z "${USER_ID:-}" ]; then
      CREATE_OUT=$(kubectl exec -n "$NAMESPACE" "$HEADSCALE_POD" -c {{ .Chart.Name }} -- headscale users create "$CLIENT_USER" --output json)
      USER_ID=$(printf "%s" "$CREATE_OUT" | jq -r '.id')
    fi
    if [ -z "$USER_ID" ]; then
      echo "[ERROR] Could not determine user ID for '$CLIENT_USER'"
      exit 1
    fi
    echo "[INFO] Using USER_ID=$USER_ID for '$CLIENT_USER'"

    # --- Step 3: Check for existing valid preauth key ---
    echo "[INFO] Checking for existing valid preauth keys..."
    KEYS_JSON=$(kubectl exec -n "$NAMESPACE" "$HEADSCALE_POD" -c {{ .Chart.Name }} -- headscale preauthkeys list -u "$USER_ID" -o json 2>/dev/null || printf 'null')
    NOW_EPOCH=$(date +%s)

    # Extract non-expired keys using shell date for Alpine compatibility
    VALID_KEYS=""
    VALID_KEYS=$(printf "%s" "$KEYS_JSON" | jq -r '(. // []) | .[] | select(.expiration != null) | "\(.key) \(.expiration)"' 2>/dev/null | while read -r key exp; do
      [ -n "$key" ] || continue
      # Strip fractional seconds for date -d compatibility
      exp_clean=$(printf "%s" "$exp" | sed 's/\.[0-9]*Z$/Z/; s/\.[0-9]*+/+/')
      exp_epoch=$(date -d "$exp_clean" +%s 2>/dev/null || echo 0)
      if [ "$exp_epoch" -gt "$NOW_EPOCH" ]; then
        printf "%s\n" "$key"
      fi
    done) || true

    if [ -n "$VALID_KEYS" ]; then
      echo "[INFO] Found valid (non-expired) preauth key(s)."

      # Check if the authkey secret already exists and contains a valid key
      EXISTING_KEY=""
      if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
        EXISTING_KEY=$(kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.authkey}' | base64 -d 2>/dev/null || true)
      fi

      # Check if the existing secret key is among the valid keys
      if [ -n "$EXISTING_KEY" ] && printf "%s" "$VALID_KEYS" | grep -qxF "$EXISTING_KEY"; then
        echo "[INFO] Authkey secret '$SECRET_NAME' already contains a valid key. Nothing to do."
        if [ -n "${AUTH_FILE_PATH:-}" ]; then
          printf "%s" "$EXISTING_KEY" > "$AUTH_FILE_PATH"
          echo "[INFO] Wrote existing authkey to $AUTH_FILE_PATH"
        fi
        exit 0
      fi

      # Secret is missing or stale; pick the first valid key and update
      AUTH_KEY=$(printf "%s" "$VALID_KEYS" | head -n1)
      echo "[INFO] Updating secret '$SECRET_NAME' with existing valid key."
    else
      # --- Step 4: No valid key; create a new one ---
      echo "[INFO] No valid preauth key found. Creating a new one..."
      AUTH_KEY=""
      for i in 1 2 3 4 5; do
        {{- if gt (len .Values.client.advertiseRoutes) 0 }}
        PAK_OUT=$(kubectl exec -n "$NAMESPACE" "$HEADSCALE_POD" -c {{ .Chart.Name }} -- headscale preauthkeys create -u "$USER_ID" --reusable --expiration {{ .Values.client.preauthKeyExpiration | default "87600h" }} --tags tag:in-cluster-client -o json 2>&1 || true)
        {{- else }}
        PAK_OUT=$(kubectl exec -n "$NAMESPACE" "$HEADSCALE_POD" -c {{ .Chart.Name }} -- headscale preauthkeys create -u "$USER_ID" --reusable --expiration {{ .Values.client.preauthKeyExpiration | default "87600h" }} -o json 2>&1 || true)
        {{- end }}
        AUTH_KEY=$(printf "%s" "$PAK_OUT" | jq -r '.key // empty' | head -n1)
        if [ -n "${AUTH_KEY:-}" ]; then
          break
        fi
        echo "[WARN] Could not obtain preauth key (attempt $i). Retrying in 3s..."
        sleep 3
      done
      if [ -z "${AUTH_KEY:-}" ]; then
        echo "[ERROR] Failed to create preauth key after multiple attempts. Last output:" >&2
        echo "$PAK_OUT" >&2
        exit 1
      fi
      echo "[INFO] Created new preauth key (redacted)."
    fi

    # --- Step 5: Create/update the secret ---
    echo "[INFO] Creating or updating secret '$SECRET_NAME'..."
    kubectl create secret generic "$SECRET_NAME" -n "$NAMESPACE" \
      --from-literal=authkey="$AUTH_KEY" \
      --dry-run=client -o yaml | kubectl apply -f - || { echo "[ERROR] Failed to create/apply secret '$SECRET_NAME'" >&2; exit 1; }

    # If AUTH_FILE_PATH is set (init container mode), also write to local file
    if [ -n "${AUTH_FILE_PATH:-}" ]; then
      printf "%s" "$AUTH_KEY" > "$AUTH_FILE_PATH"
      echo "[INFO] Wrote authkey to $AUTH_FILE_PATH"
    fi

    echo "[INFO] Done."
{{- end }}
